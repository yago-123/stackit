package storage

import (
	"fmt"

	"github.com/yago-123/stackit/pkg/encoding"

	"github.com/yago-123/stackit/config"
	"github.com/yago-123/stackit/pkg/types"

	"context"

	"github.com/redis/go-redis/v9"
)

const (
	FirstNameKey = "FirstName"
	LastNameKey  = "LastName"
	EmailKey     = "Email"
)

type Redis struct {
	cfg *config.Config
	rdb *redis.Client
}

func NewRedis(ctx context.Context, cfg *config.Config, _ encoding.Encoder) *Redis {
	// todo() all options must be set from cfg instead
	rdb := redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "",
		DB:       0,
	})

	// Test the connection
	_, err := rdb.Ping(ctx).Result()
	if err != nil {
		panic(err)
	}

	return &Redis{
		cfg: cfg,
		rdb: rdb,
	}
}

// Disclaimer: generated by ChatGPT
func (r *Redis) PersistUser(user types.User) error {
	// todo(): handle the case in which the user is already present in the DB

	key := fmt.Sprintf("user:%s", user.Email)
	return r.rdb.HSet(context.Background(), key, map[string]interface{}{
		FirstNameKey: user.FirstName,
		LastNameKey:  user.LastName,
		EmailKey:     user.Email,
	}).Err()
}

// Disclaimer: generated by ChatGPT
// Disclaimer: pretty bad option in terms of performance
func (r *Redis) RetrieveUsers() ([]types.User, error) {
	var users []types.User

	iter := r.rdb.Scan(context.Background(), 0, "user:*", 0).Iterator()
	for iter.Next(context.Background()) {
		key := iter.Val()
		fields, err := r.rdb.HGetAll(context.Background(), key).Result()
		if err != nil {
			return nil, err
		}

		user := types.User{
			FirstName: fields[FirstNameKey],
			LastName:  fields[LastNameKey],
			Email:     fields[EmailKey],
		}
		users = append(users, user)
	}

	if err := iter.Err(); err != nil {
		return nil, err
	}

	return users, nil
}
